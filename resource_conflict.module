<?php

/**
 * Check a node for conflicts
 */
function resource_conflict_check_node($node) {
  // Check the content type to make sure conflict handling is enabled.
  $type = $node->type;
  if (!variable_get('rc_type_' . $type, FALSE)) {
    return;
  }

  // Find the date field to use for time overlapping_node_ids detection.
  $date_field = variable_get('rc_date_field_' . $type, FALSE);

  $overlapping_node_ids = array();
  // Get the start and end Date of the current node, accounting for repeat dates
  $time_spans_raw = array();
  $date_items = field_get_items('node', $node, $date_field);
  $date_field_info = field_info_field($date_field);
  $date_format = date_type_format($date_field_info['type']);

  foreach ($date_items as $single_repetition_date) {
    // Avoid the "Add another item" row for repeat dates
    if (!is_array($single_repetition_date)) {
      continue;
    }
    // Unix stamps should be interpreted as integers, but field_get_items pulls them
    // out as strings. We need to cast back to int or our database comparisons fail
    if ($date_format == DATE_FORMAT_UNIX) {
      $start = (int)$single_repetition_date['value'];
      $end = (int)$single_repetition_date['value2'];
    } else {
      $start = $single_repetition_date['value'];
      $end = $single_repetition_date['value2'];
    }
    $time_spans_raw[] = array(
      'start' => $start,
      'end' => $end,
    );
  }

  // Get all conflicting Date nodes
  if (isset($time_spans_raw)) {
    $overlapping_node_ids = _resource_conflict_get_overlaps($time_spans_raw);
  }
  else {
    // If we got here, someone broke the requirements, so log the problem and move on
    watchdog('resource_conflict', 'Conflict checking is enabled for Content type %type, but no date field has been selected for conflict checking.', array('%type' => $type), 'WATCHDOG_ERROR');
  }

  // Load conflicting nodes
  $conflicting_nodes = array();
  foreach ($overlapping_node_ids as $nid) {
    // Don't have the node conflict with itself
    if ($nid != $node->nid) {
      $conflicting_nodes[] = node_load($nid);
    }
  }
  // Fire Rules action for each conflict detected
  foreach ($conflicting_nodes as $conflicting_node) {
    rules_invoke_event('resource_conflict_conflict_detected', $node, $conflicting_node);
  }
  if (!$conflicting_nodes) {
    return FALSE;
  }
  return $conflicting_nodes;
}

/**
 * Sneak a form error into validation with the Session variable.
 * It's a dirty hack, but it will work for now.
 */
function resource_conflict_form_error($message) {
  $_SESSION['resource_conflict_message']['items'][] = $message;
}

/**
 * Implements hook_node_validate().
 * Throws a validation error for any errors set in SESSION
 * TODO: a better way to throw form errors with Rules.
*/
function resource_conflict_node_validate($node, $form) {
  $type = $node->type;
  if (!variable_get('rc_type_' . $type, FALSE)) {
    // Conflict handling is not enabled for this content type
    return;
  }
  rules_invoke_event('resource_conflict_node_validation', $node, $form);
  if (isset($_SESSION['resource_conflict_message'])) {
    // Find the date field that handles conflicts
    $date_field = variable_get('rc_date_field_' . $type, FALSE);
    $form_error = theme('item_list', $_SESSION['resource_conflict_message']);
    form_set_error($date_field, $form_error);
    unset($_SESSION['resource_conflict_message']);
  }
}


/**
 * Rules Condition: check a node object for conflicts.
 */
function resource_conflict_contains_conflict($node) {
  $conflicting_nodes = resource_conflict_check_node($node);
  if (!$conflicting_nodes) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Rules Action: load list of conflicting nodes, if any
 */
function resource_conflict_load_conflict_list($node) {
  $conflict_list = resource_conflict_check_node($node);
  if (!$conflict_list) {
    return FALSE;
  }
  return array('conflict_list' => $conflict_list);
}

/**
 * Determine if any conflict enabled nodes overlap the specified times
 *
 * 1. $start is within the event time
 * 2. $end is within the event time
 * 3. The event encompasses $start and $end
 * 4. Allow the end of one event to occur at the start of the next
 *
 * @param $time_spans
 *   An array of 'time span' arrays with the following keys:
 *   - start: Start of an event
 *   - end: End of an event
 *   The date format of each pair is that of the unsaved node's date format
 *   All date fields that are compared must be of the same format
 * @return
 *   An array of node IDs.
 */
function _resource_conflict_get_overlaps($time_spans) {
  $nids = array();
  $conflict_types = variable_get("rc_types", array());
  foreach ($conflict_types as $type) {
    $date_field = variable_get('rc_date_field_' . $type, FALSE);
    $date_table = '{field_data_' . $date_field . '}';
    $start_field = 'date_table.' . $date_field . '_value';
    $end_field = 'date_table.' . $date_field . '_value2';

    foreach ($time_spans as $time_span) {
      $query = db_select('node', 'n');
      $query->join($date_table, 'date_table', 'n.nid = date_table.revision_id');
      $query->fields('n', array('nid'))
            ->condition(db_or()
              ->condition(db_and()->condition($start_field, $time_span['start'], '<=')->condition($end_field, $time_span['start'], '>'))
              ->condition(db_and()->condition($start_field, $time_span['end'], '<')->condition($end_field, $time_span['end'], '>='))
              ->condition(db_and()->condition($start_field, $time_span['start'], '>=')->condition($end_field, $time_span['end'], '<='))
            )->distinct();
      $result = $query->execute();

      $nids = array_merge($nids, $result->fetchCol());
    }
  }
  return array_unique($nids);
}

/**
 * Implements hook_form_alter().
 */
function resource_conflict_form_alter(&$form, $form_state, $form_id) {
  if ($form_id != 'node_type_form') {
    return;
  }

  $type = (isset($form['old_type']) && isset($form['old_type']['#value'])) ? $form['old_type']['#value'] : NULL;

  $form['resource_conflict_set'] = array(
    '#type' => 'fieldset',
    '#title' => t('Resource Conflict'),
    '#collapsible' => TRUE,
    '#group' => 'additional_settings',
  );

  // The user is adding a new content type
  if ($type == NULL) {
    $form['resource_conflict_set']['rc_info'] = array(
      '#prefix' => '<p>',
      '#suffix' => '</p>',
      '#value' => t('To set up this content type for conflict checking, first add a Date field with required start and end dates. When the conditions have been met, this section will be enabled for configuration.'),
    );
    return;
  }

  $date_fields = array();
  $fields = field_info_instances('node', $type);
  foreach ($fields as $field_name => $field) {
    $field_info = field_info_field($field_name);

    if ($field_info['module'] == 'date' && $field['required'] == 1 && $field_info['settings']['todate'] == 'required') {
      $date_fields[$field_name] = $field['label'];
    }
  }

  if (empty($date_fields)) {
    $form['resource_conflict_set']['requirements'] = array(
      '#type' => 'markup',
      '#prefix' => '<p>', 
      '#suffix' => '</p>',
      '#weight' => -10,
      '#markup' => t('This content type does not contain any suitable Date fields. Please add at least one Date field with required start and end dates.'),
    );
  }
  else {
    $form['resource_conflict_set']['rc_type'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable resource conflict checking for this content type'),
      '#default_value' => variable_get('rc_type_' . $type, 0),
      '#weight' => -8,
    );

    $form['resource_conflict_set']['rc_date_field'] = array(
      '#type' => 'select',
      '#title' => t('Field to use as the date for conflict checks'),
      '#options' => $date_fields,
      '#multiple' => FALSE,
      '#default_value' => variable_get('rc_date_field_' . $type, FALSE),
      '#description' => t("Select the date field to use to check for resource conflicts."),
    );

  }

  // Add our custom submission handler so we can manage the RC settings
  $form['#submit'][] = 'resource_conflict_form_submit';
}

/**
 * Our custom submit handler for when a content type is saved
 */
function resource_conflict_form_submit($form, &$form_state) {
  $type = $form_state['values']['type'];

  if (isset($form_state['values']['rc_type']) && $form_state['values']['rc_type'] == 1) {
    _resource_conflict_add_type($type);
  } else {
    _resource_conflict_remove_type($type);
  }
}

/**
 * Implements hook_field_delete_instance()
 *
 * If this field was assigned as an RC date field, we want to delete it's data
 * from our registry and possibly warn the user that RC was disabled for this
 * content type
 */
function resource_conflict_field_delete_instance($instance) {
  $rc_date_field = variable_get('rc_date_field_' . $instance['bundle'], FALSE);
  if ($rc_date_field == $instance['field_name']) {
    variable_del('rc_date_field_' . $instance['bundle']);

    // Msg user if the content type was enabled for RC
    $content_type_enabled = variable_get('rc_type_'. $instance['bundle'], FALSE);
    if ($content_type_enabled == 1) {
      $msg = t('Resource Conflict has been disabled for the %type content type as the date field has been deleted.', array('%type' => $instance['bundle']));
      drupal_set_message($msg, 'warning');
      watchdog('resource conflict', $msg, WATCHDOG_WARNING);
    }

    // Delete the reg values for this content type whether it was enabled or not
    _resource_conflict_remove_type($instance['bundle']);
  }
}

/**
 * Implements hook_field_update_instance()
 * Notice when an RC-enabled field is modified, and make sure it still meets requirements.
 */
function resource_conflict_field_update_instance($instance, $prior_instance) {
  if (variable_get('rc_type_' . $instance['bundle'], FALSE) && variable_get('rc_date_field_' . $instance['bundle'], FALSE) == $instance['field_name']) {
    $field = field_info_field($instance['field_name']);
    if ($instance['required'] != 1 || $field['settings']['todate'] != 'required') {
      variable_del('rc_date_field_' . $instance['bundle']);
      _resource_conflict_remove_type($instance['bundle']);

      $msg = t('Resource Conflict has been disabled for the %type content type as the date field no longer meets requirements', array('%type' => $instance['bundle']));
      drupal_set_message($msg, 'warning');
      watchdog('resource conflict', $msg, WATCHDOG_WARNING);
    }
  }
}

/**
 * Adds the provided content type to our list of enabled RC types
 */
function _resource_conflict_add_type($content_type) {
  $conflict_types = variable_get("rc_types", array());

  if (!in_array($content_type, $conflict_types)) {
    $conflict_types[] = $content_type;
    variable_set("rc_types", $conflict_types);
  }
}

/**
 * Removes the provided content type from our list of enabled RC types
 */
function _resource_conflict_remove_type($content_type) {
  $conflict_types = variable_get("rc_types", array());

  if (($key = array_search($content_type, $conflict_types)) !== FALSE) {
    unset($conflict_types[$key]);
    variable_set("rc_types", $conflict_types);
  }

  variable_del('rc_type_'. $content_type);
}


